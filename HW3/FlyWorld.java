import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.awt.Color;
import java.util.Random;


/**
 * Contains information about the world (i.e., the grid of squares)<br>
 * and handles most of the game play work that is NOT GUI specific
 */
public class FlyWorld
{
    protected int numRows;
    protected int numCols;
    protected int numFrogs;
    protected int numSpiders;

    protected GridLocation [][] world;

    protected GridLocation start;
    protected GridLocation goal;
    
    protected Fly mosca;
    protected Frog[] frogs;
    protected Spider[] spiders;

    /**
     * Reads a file containing information about<br>
     * the grid setup.  Initializes the grid<br>
     * and other instance variables for use by<br>
     * FlyWorldGUI and other pieces of code.
     *
     *@param fileName the file containing the world grid information
     */
    public FlyWorld(String fileName){
        try {
            File inputFile = new File(fileName);
            Scanner scan = new Scanner(inputFile);
            numRows = scan.nextInt();
            numCols = scan.nextInt();
            scan.nextLine(); // take care of the trailing new line (\n)

            world = new GridLocation [numRows][numCols];
            frogs = new Frog[numCols * numRows]; // initialize the frog list (all null) with max capacity = rows * cols
            spiders = new Spider[numCols * numRows];

            for (int i = 0; i < numRows; i++) {
                String line = scan.nextLine().trim();
                for (int j = 0; j < numCols; j++) {
                    char symbol = line.charAt(j);
                    world[i][j] = new GridLocation(i, j);

                    if (symbol == 'f') {
                        Frog frog = new Frog(world[i][j], this); // create a Frog object in FlyWorld
                        frogs[numFrogs++] = frog; // put frog in list, increment num of frogs (def 0) = 1
                    } else if (symbol == 'h') {
                        world[i][j].setBackgroundColor(Color.red); // ULTIMATE DESTINATION of Mosca
                        this.goal = world[i][j];
                    } else if (symbol == 's') {
                        world[i][j].setBackgroundColor(Color.green); // starting point for Mosca
                        this.start = world[i][j];
                        mosca = new Fly(world[i][j], this);
                    } else if (symbol == 'a') {
                        Spider spider = new Spider(world[i][j], this);
                        spiders[numSpiders++] = spider;
                    }
                }
            }
            scan.close();
        } catch (FileNotFoundException e) {
            System.out.println("File not found");
        }
    }

    public int getNumRows(){
        return numRows;
    }

    public int getNumCols(){
        return numCols;
    }

    /**
     * Deterimes if a specific row/column location is<br>
     * a valid location in the world (i.e., it is not out of bounds)
     *
     * @param r a row
     * @param c a column
     *
     * @return boolean
     */
    public boolean isValidLoc(int r, int c){
        if (r < 0 || r >= numRows || c < 0 || c >= numCols) {
            return false;
        }
        return true; // THIS LINE IS JUST SO CODE COMPILES
    }

    /**
     * Returns a specific location based on the given row and column
     *
     * @param r the row
     * @param c the column
     *
     * @return GridLocation
     */
    public GridLocation getLocation(int r, int c){
        return world[r][c];
    }

    /**
     * @return FlyWorldLocation, the location of the fly in the world
     */
    public GridLocation getFlyLocation(){
        return mosca.getLocation();
    }

    /**
     * Moves the fly in the given direction (if possible)
     * Checks if the fly got home or was eaten
     *
     * @param direction the direction, N,S,E,W to move
     *
     * @return int, determines the outcome of moving fly<br>
     *              there are three possibilities<br>
     *              1. fly is at home, return ATHOME (defined in FlyWorldGUI)<br>
     *              2. fly is eaten, return EATEN (defined in FlyWorldGUI)<br>
     *              3. fly not at home or eaten, return NOACTION (defined in FlyWorldGUI)
     */
    public int moveFly(int direction){
        mosca.update(direction);
        GridLocation moscaNow = mosca.getLocation();

        // Check if the fly land on the goal square
        if (moscaNow.equals(goal)) {
            return FlyWorldGUI.ATHOME;
        } 

        // Check if the fly is eaten by any of the existing frogs
        for (Frog frog : frogs) {
            if (frog != null) { // EVERY SQUARE WITHOUT A FROG IS NULL as generated by frogs = new Frog[numCols * numRows];
                if (frog.eatsFly()) {
                    return FlyWorldGUI.EATEN;
                }
            }
        }

        for (Spider spider : spiders) {
            if (spider != null) {
                if (spider.eatsFly()) {
                    return FlyWorldGUI.EATEN;            
                }
            }
        }
        return FlyWorldGUI.NOACTION; // THIS LINE IS JUST SO CODE COMPILES
    }

    /**
     * Moves all predators. After it moves a predator, checks if it eats fly
     *
     * @return boolean, return true if any predator eats fly, false otherwise
     */
    public boolean movePredators(){

        for (Frog frog : frogs) {
            if (frog != null) {
                frog.update();

                if (frog.eatsFly()) {
                    return true;
                }   
            }
        }

        for (Spider spider : spiders) {
            if (spider != null) {
                spider.update();

                if (spider.eatsFly()) {
                    return true;
                }   
            }
        }
        return false; // THIS LINE IS JUST SO CODE COMPILES
    }
}
